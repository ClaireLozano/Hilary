var _ = require('underscore');
var ShortId = require('shortid');

var AuthzUtil = require('oae-authz/lib/util');
var Cassandra = require('oae-util/lib/cassandra');
var OaeUtil = require('oae-util/lib/util');
var TenantsAPI = require('oae-tenants');
var ContentAPI = require('oae-content');
var LibraryAPI = require('oae-library');

var ContentDAO = require('oae-content/lib/internal/dao.content.js');
var PrincipalDAO = require('oae-principals/lib/internal/dao.js');

var Favorites = require('oae-favorites/lib/model').Favorites;
var FavoritesConstants = require('../constants').FavoritesConstants;

/**
 * Add to the libraries of a principal.
 *
 * @param  {String}    	idPrincipal                 Id of the principal
 * @param  {String}  	idResource                  Id of the resource to add to the favorites list
 * @param  {Function}   [callback]                  Standard callback function
 * @param  {Object}     [callback.err]              Error object containing the error message
 * @param  {Content}    [callback.newContentObj]    The content object with the updated `lastModified` field. Note that this may be returned even if there is an error as the content-update operation may have succeeded but the library-update operation fails.
 */
var addToFavorites = module.exports.addToFavorites = function(idPrincipal, idResource , callback) {

	_isInFavorites(idPrincipal, idResource, function(err, result){
		if (err) {
			return callback(err);
		}

		if (result) {
			// Create the content
		    Cassandra.runQuery('INSERT INTO "Favorites" ("idPrincipal", "idResource", "favorite") VALUES (?, ?, ?)', [idPrincipal, idResource, 'true'], function(err) {
		        if (err) {
		            return callback(err);
		        }

		        var FavoritesObj = new Favorites(idPrincipal, idResource, 'true');

		        ContentDAO.getContent(idResource, function(err, resource){
		    		if (err) {
		    			return callback(err);
		    		}
		    		_insertFavoriteLibraries(resource, [idPrincipal], function(err, resourceObj){
		    			if (err) {
		    				return callback(err);
		    			}

		    			return callback(null, resourceObj);
					});
		        });
			});
		}
		return callback(null);
	});
};

/**
 * Updates the libraries of all of the members of a piece of content. This will remove the old entry with
 * the old lastModified date/sorting and add the new one. The content item's `lastModified` timestamp will
 * be updated such that it ranked higher in libraries.
 *
 * @param  {Object}    	resource                  	The resource to add in favorites
 * @param  {String}   	idPrincipal              	Id of the principal
 * @param  {Function}   [callback]                  Standard callback function
 * @param  {Object}     [callback.err]              Error object containing the error message
 */
var _insertFavoriteLibraries = function(resource, idPrincipal, callback) {

    // Update the content item with a new timestamp.
    ContentDAO.updateContent(resource, {}, false, function(err, newResourceObj) {
        if (err) {
            return callback(err);
        }
        // We are creating a new content item. We only care about who is getting added, so
	    // insert it into the library index for all members
	    var insertEntries = _.map([idPrincipal], function(id) {
	        return {
	            'id': id,
	            'rank': newResourceObj.lastModified,
	            'resource': resource
	        };
	    });
	    return LibraryAPI.Index.insert(FavoritesConstants.library.FAVORITES_LIBRARY_INDEX_NAME, insertEntries, callback);
    });
};


/**
 * Internal function that updates the content libries for a piece of content.
 *
 * @param  {String}    	idMember          	Id of the principal
 * @param  {String}     idResource     		The resource to add in favorites
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var _isInFavorites = function(idMember, idResource, callback) {
	Cassandra.runQuery('SELECT * FROM "Favorites" WHERE "idPrincipal" = ? AND "idResource" = ?', [idMember, idResource], function (err, result) {
		if (err) {
			return callback(err);
		}

        if (result) {
        	return callback(null, true);
        } else {
        	return callback(null, false);
        }
    });
};

/**
 * Get a user's or group's content library
 *
 * @param  {String}         principalId         The ID of the principal for which the library should be retrieved.
 * @param  {String}         visibility          Which library should be returned.
 * @param  {String}         start               Determines the point at which content items are returned for paging purposed.  If not provided, the first x elements will be returned
 * @param  {Number}         limit               Number of items to return. Will default to 10 if not provided
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 * @param  {Content[]}      callback.content    Array of basic content profiles representing the requested items in the library
 * @param  {String}         callback.nextToken  The value to use for the `start` parameter to get the next set of results
 */
var getFavoritesLibraryItems = module.exports.getFavoritesLibraryItems = function(principalId, visibility, start, limit, callback) {
    limit = OaeUtil.getNumberParam(limit, 10);

    LibraryAPI.Index.list(FavoritesConstants.library.FAVORITES_LIBRARY_INDEX_NAME, principalId, visibility, {'start': start, 'limit': limit}, function(err, entries, nextToken) {
        if (err) {
        	console.log(err)
            return callback(err);
        }
        var resourceIds = _.pluck(entries, 'resourceId');
        ContentDAO.getMultipleContentItems(resourceIds, null, function(err, contentItems) {
            if (err) {
                return callback(err);
            }
            // If the library was stale or dirty, it might contain ids for content
            // items that no longer exist. Remove these from the returned result set
            contentItems = _.compact(contentItems);

            return callback(null, contentItems, nextToken);
        });
    });
};
























/**
 * Internal function that updates the content libries for a piece of content.
 *
 * @param  {Content}    contentObj          The content object for which the libraries should be updated
 * @param  {Number}     oldLastModified     The timestamp when the content item was last modified. (Note: this is the timestamp that is used in the libraries)
 * @param  {Number}     newLastModified     The new timestamp
 * @param  {String[]}   removedMembers      An array of principal IDs that should no longer have this item in their library.
 * @param  {Function}   [callback]          Standard callback function
 * @param  {Object}     [callback.err]      Error object containing the error message
 */
var _updateFavoritesResourceLibraries = function(contentObj, oldLastModified, newLastModified, removedMembers, callback) {
    // Grab all the current members.
    ContentDAO.getAllContentMembers(contentObj.id, function(err, members) {
        if (err) {
            return callback(err);
        }

        // The member list who has the resource in their favorites list
        memberList = [];

        // Get all member who has this content into his library favorites list
        members.forEach(function(member, idx, array){

        	_isInFavorites(member.id, contentObj.id, function(err, result){
        		if (err) {
        			return callback(err);
        		}
        		// Add the member to the list
        		if (result) {
        			memberList.push(member);
        		}
        		// When all the member are analysed, start the library favorite modification
        		if (idx === array.length - 1) { 

        			// Extract all the member ids from the members response
			        var memberIds = _.pluck(memberList, 'id');

			        if (!oldLastModified) {
			            // We are creating a new content item. We only care about who is getting added, so
			            // insert it into the library index for all members
			            var insertEntries = _.map(memberIds, function(memberId) {
			                return {
			                    'id': memberId,
			                    'rank': newLastModified,
			                    'resource': contentObj
			                };
			            });
			            return LibraryAPI.Index.insert(FavoritesConstants.library.FAVORITES_LIBRARY_INDEX_NAME, insertEntries, callback);
			        }

			        // Collect any library index update operations from the member ids that are not removal
			        // entries
			        var updateEntries = _.chain(memberIds)
			            .difference(removedMembers)
			            .map(function(memberId) {
			                return {
			                    'id': memberId,
			                    'newRank': newLastModified,
			                    'oldRank': oldLastModified,
			                    'resource': contentObj
			                };
			            })
			            .value();

			        // Collect any library index remove operations from the member ids that are being removed
			        var removeEntries = _.map(removedMembers, function(removedMemberId) {
			            return {
			                'id': removedMemberId,
			                'rank': oldLastModified,
			                'resource': contentObj
			            };
			        });
			        // Apply the index updates, if any
			        OaeUtil.invokeIfNecessary(!_.isEmpty(updateEntries), LibraryAPI.Index.update, FavoritesConstants.library.FAVORITES_LIBRARY_INDEX_NAME, updateEntries, function(err) {
			            if (err) {
			                return callback(err);
			            }

			            // Apply the index removals, if any
			            return OaeUtil.invokeIfNecessary(!_.isEmpty(removeEntries), LibraryAPI.Index.remove, FavoritesConstants.library.FAVORITES_LIBRARY_INDEX_NAME, removeEntries, callback);
			        });
        		}
        	}); 
        });
    });
};

